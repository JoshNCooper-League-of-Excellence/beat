import fmt::*;
import lexer::*;
import parser::*;
import interp::*;

#c_flags " -lm "
#foreign fmod :: fn(a: f64, b: f64) -> s32;

bootstrap_builtin_functions :: fn(root: *mut Node) {
  root.block.scope.insert("print".as_string(), Rc!<Value>::new(Value.{
    tag: ValueTag::NativeFunction,
    native_function: fn(args: List!<Rc!<Value>>) -> Rc!<Value> {
      mut builder: StringBuilder;
      options := FormatOptions::default();
      for arg in args {
        (*arg).format(&mut builder, options);
        builder.append(" ");
      }
      mut string := builder.get_string();
      println(string);
      string.deinit();
      builder.deinit();
    }
  }));

  root.block.scope.insert("mod".as_string(), Rc!<Value>::new(Value.{
    tag: ValueTag::NativeFunction,
    native_function: fn(args: List!<Rc!<Value>>) -> Rc!<Value> {
      if args.length != 2 {
        return Value::None();
      }
      a := args[0].ptr.number;
      b := args[1].ptr.number;
      result := fmod(a as f32, b as f32);
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Number,
        number: result,
      });
    }
  }));

  root.block.scope.insert("range".as_string(), Rc!<Value>::new(Value.{
    tag: ValueTag::NativeFunction,
    native_function: fn(args: List!<Rc!<Value>>) -> Rc!<Value> {
      if args.length < 2 {
        return Value::None();
      }
      min := args[0].ptr.number;
      max := args[1].ptr.number;
      mut increment := 1.0;
      if args.length > 2 {
        increment = args[2].ptr.number;
      }
      count := ((max - min) / increment) as u64;
      mut array: List!<Rc!<Value>>;
      for i in 0..count {
        array.push(Rc!<Value>::new(Value.{
          tag: ValueTag::Number,
          number: min + (i as f64) * increment,
        }));
      }
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Array,
        array: array,
      });
    }
  }));
}

main :: fn() {
  args := Env::args();
  mut path: String;
  if args.length >= 2 {
    path = String::from(args[1]);
  } else {
    printf("too few arguments!\nusage: beat <filename.beat>"c);
    return;
  }

  mut lexer := Lexer::new(path);
  mut parser := Parser::new();
  mut root := parser.parse(&mut lexer);

  bootstrap_builtin_functions(root);

  mut interp: Interp;
  interp.run(root);
}