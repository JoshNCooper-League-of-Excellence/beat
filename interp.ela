import parser::*;

impl!<T> T[] {
  reverse :: fn(*mut self) {
    len := self.length;

    if len <= 1 then return;

    for i in 0..(len / 2) {
      high := len - 1 - i;
      low := i;
      temp := self.data[low];
      self.data[low] = self.data[high];
      self.data[high] = temp;
    }
  }
}

Interp :: struct {
  scope: *mut Scope,
  nodes: Node[],
}

ControlFlow :: enum {
  None,
  Continue,
  Break,
  Return,
}

StatementResult :: struct {
  control_flow: ControlFlow,
  value: Option!<Rc!<Value>>,
}

impl Interp {
  new :: fn(mut nodes: Node[]) -> #self {
    nodes.reverse();
    return .{
      scope: new(Scope.{}),
      nodes: nodes,
    };
  }
  
  get_node :: fn(*mut self, index: NodeID) -> *mut Node {
    // we reverse the nodes when we interpret, so we have to do this weird indexing scheme.
    return &mut self.nodes[self.nodes.length - 1 - index];
  }

  visit_if :: fn(*mut self, node: *mut Node) -> StatementResult {
    return .{}
  }
  visit_else :: fn(*mut self, node: *mut Node) -> StatementResult {
    return .{}
  }
  visit_while :: fn(*mut self, node: *mut Node) -> StatementResult {
    return .{}
  }
  visit_for :: fn(*mut self, node: *mut Node) -> StatementResult {
    return .{}
  }
  visit_binary :: fn(*mut self, node: *mut Node) -> Rc!<Value> {
    switch node.binary.operator {
      TType::Add: {
        return self.visit_expression(self.get_node(node.binary.left)).add(
          self.visit_expression(self.get_node(node.binary.right)),
        );
      }
      TType::Sub: {
        return self.visit_expression(self.get_node(node.binary.left)).sub(
          self.visit_expression(self.get_node(node.binary.right)),
        );
      }
      TType::Mul: {
        return self.visit_expression(self.get_node(node.binary.left)).mul(
          self.visit_expression(self.get_node(node.binary.right)),
        );
      }
      TType::Div: {
        return self.visit_expression(self.get_node(node.binary.left)).div(
          self.visit_expression(self.get_node(node.binary.right)),
        );
      }
      TType::LT: {
        return self.visit_expression(self.get_node(node.binary.left)).div(
          self.visit_expression(self.get_node(node.binary.right))
        );
      }
      TType::LTE: {
        return self.visit_expression(self.get_node(node.binary.left)).lte(
          self.visit_expression(self.get_node(node.binary.right))
        );
      }
      TType::GT: {
        return self.visit_expression(self.get_node(node.binary.left)).gt(
          self.visit_expression(self.get_node(node.binary.right)),
        );
      }
      TType::GTE: {
        return self.visit_expression(self.get_node(node.binary.left)).lte(
          self.visit_expression(self.get_node(node.binary.right))
        );
      }
      TType::EQ: {
        return self.visit_expression(self.get_node(node.binary.left)).eq(
          self.visit_expression(self.get_node(node.binary.right))
        );
      }
      TType::NEQ: {
        return self.visit_expression(self.get_node(node.binary.left)).neq(
          self.visit_expression(self.get_node(node.binary.right)),
        );
      }
      TType::Assign: {
        mut left := self.visit_expression(self.get_node(node.binary.left));
        right := *self.visit_expression(self.get_node(node.binary.right));
        *left.ptr = right;
      }
    }
    return Value::None();
  }
  visit_unary :: fn(*mut self, node: *mut Node) -> Rc!<Value> {
    return .{}
  }

  visit_call :: fn(*mut self, node: *mut Node) -> Rc!<Value> {
    function := *self.visit_expression(self.get_node(node.call.callee));
    mut args: List!<Rc!<Value>>;
    for arg in node.call.arguments {
      arg_node := self.get_node(arg);
      value := self.visit_expression(arg_node);
      args.push(value);
    }

    if function.tag == ValueTag::NativeFunction {
      return function.native_function(args);
    } else if function.tag == ValueTag::Function {
      return self.visit_function(function.function, args);
    } else {
      panic("cannot call a non function");
      return .{};
    }
  }
  
  visit_member_access :: fn(*mut self, node: *mut Node) -> Rc!<Value> {
    object := *self.visit_expression(self.get_node(node.member_access.base));
    if object.tag != ValueTag::Object {
      panic("cannot access member of a non-object");
      return .{};
    }

    member := node.member_access.member;
    value := object.object.get(member);
    if value.is_none() {
      panic("member not found in object");
      return .{};
    }

    return value.unwrap().clone();
  }

  visit_subscript :: fn(*mut self, node: *mut Node) -> Rc!<Value> {
    array := self.visit_expression(self.get_node(node.subscript.base)).ptr;
    if array.tag != ValueTag::Array {
      panic("cannot subscript a non-array");
      return .{};
    }

    index := *self.visit_expression(self.get_node(node.subscript.index));
    if index.tag != ValueTag::Number {
      panic("array index must be a number");
      return .{};
    }

    idx := index.number as u64;
    if idx >= array.array.length {
      panic("array index out of bounds");
      return .{};
    }

    return array.array[idx].clone();
  }

  visit_object_literal :: fn(*mut self, node: *mut Node) -> Rc!<Value> {
    mut object: Map!<String, Rc!<Value>>;

    for key, value_node in node.object_literal.key_values {
      value := self.visit_expression(self.get_node(value_node));
      object.insert(key, value);
    }

    return Rc!<Value>::new(Value.{
      tag: ValueTag::Object,
      object: object,
    });
  }

  visit_array_literal :: fn(*mut self, node: *mut Node) -> Rc!<Value> {
    mut array: List!<Rc!<Value>>;

    for element_node in node.array_literal.values {
      value := self.visit_expression(self.get_node(element_node));
      array.push(value);
    }

    return Rc!<Value>::new(Value.{
      tag: ValueTag::Array,
      array: array,
    });
  }

  visit_block :: fn(*mut self, node: *mut Node) -> StatementResult {
    old_scope := self.scope;
    block := &mut node.block;
    mut cf: ControlFlow = ControlFlow::None;
    self.scope = block.scope;

    for statement in node.block.statements.iter_mut() {
      result := self.visit_statement(statement);

      if result.control_flow == ControlFlow::Return 
        then return result;
    }

    defer self.scope = old_scope;
    return .{
      control_flow: ControlFlow::None,
      value: None(),
    };
  }

  visit_variable :: fn(*mut self, node: *mut Node) -> StatementResult {
    variable_name := node.variable.name;

    if node.variable.value.is_some() {
      initial_value := self.visit_expression(self.get_node(node.variable.value.unwrap()));
      self.scope.insert(variable_name, initial_value);
    } else {
      self.scope.insert(variable_name, Value::None());
    }

    return .{
      control_flow: ControlFlow::None,
      value: None(),
    };
  }

  visit_function :: fn(*mut self, function: *mut Function, args: List!<Rc!<Value>>) -> Rc!<Value> {
    mut i := 0;
    for param in function.parameters {
      if i >= args.length {
        break;
      }
      function.block.scope.insert(param, args[i]);
      i++;
    }

    mut temp_node := Node.{
      tag: NodeTag::Block,
      block: function.block,
    };

    _, value := self.visit_block(&mut temp_node);

    if value.is_none() {
      return Value::None();
    } else {
      return value.unwrap();
    }
  }

  visit_function_header :: fn(*mut self, node: *mut Node) {
    funcy := &mut node.function;

    self.scope.insert(funcy.name, Rc!<Value>::new(Value.{
      tag: ValueTag::Function,
      function: &mut node.function,
    }));

    old_scope := self.scope;
    funcy.block.scope = old_scope.create_child();
    self.scope = funcy.block.scope;

    old_nodes := self.nodes;
    self.nodes = funcy.block.statements;

    defer {
      self.nodes = old_nodes;
      self.scope = old_scope;
    }

    for param in funcy.parameters {
      self.scope.insert(param, Value::None());
    }
  }

  visit_expression :: fn(*mut self, node: *mut Node) -> Rc!<Value> {
    switch node.tag {
      NodeTag::Boolean: {
        return Rc!<Value>::new(Value.{
          tag: ValueTag::Boolean,
          boolean: node.boolean,
        });
      }
      NodeTag::None: {
        return Rc!<Value>::new(Value.{
          tag: ValueTag::None,
        });
      }
      NodeTag::Number: {
        return Rc!<Value>::new(Value.{
          tag: ValueTag::Number,
          number: node.number,
        });
      }
      NodeTag::String: {
        return Rc!<Value>::new(Value.{
          tag: ValueTag::String,
          string: node.string,
        });
      }
      NodeTag::Identifier: {
        variable := self.scope.lookup(node.identifier);
        if variable.is_none() {
          printlnf("use of undeclared variable: %", (node.identifier,));
          panic("");
        }
        return variable.unwrap().clone();
      }
      NodeTag::Binary: {
        return self.visit_binary(node);
      }
      NodeTag::Unary: {
        return self.visit_unary(node);
      }
      NodeTag::MemberAccess: {
        return self.visit_member_access(node);
      }
      NodeTag::Subscript: {
        return self.visit_subscript(node);
      }
      NodeTag::ObjectLiteral: {
        return self.visit_object_literal(node);
      }
      NodeTag::ArrayLiteral: {
        return self.visit_array_literal(node);
      }
      NodeTag::Call: {
        return self.visit_call(node);
      }
    }
    return Value::None();
  } 

  visit_statement :: fn(*mut self, node: *mut Node) -> StatementResult {
    if node.tag == NodeTag::Boolean ||
       node.tag ==  NodeTag::Number ||
       node.tag ==  NodeTag::String ||
       node.tag ==  NodeTag::Identifier ||
       node.tag ==  NodeTag::Binary ||
       node.tag ==  NodeTag::Unary ||
       node.tag ==  NodeTag::MemberAccess ||
       node.tag ==  NodeTag::Subscript ||
       node.tag ==  NodeTag::ObjectLiteral ||
       node.tag ==  NodeTag::ArrayLiteral ||
       node.tag ==  NodeTag::Call {
        return .{
          control_flow: ControlFlow::None,
          value:  Some(self.visit_expression(node)),
        }
    }
    switch node.tag {
      NodeTag::Block: {
        return self.visit_block(node);
      }
      NodeTag::If: {
        return self.visit_if(node);
      }
      NodeTag::Else: {
        return self.visit_else(node);
      }
      NodeTag::While: {
        return self.visit_while(node);
      }
      NodeTag::For: {
        return self.visit_for(node);
      }
      NodeTag::Continue: {
        return .{
          control_flow: ControlFlow::Continue,
        };
      }
      NodeTag::Break: {
        return .{
          control_flow: ControlFlow::Break,
        };
      }
      NodeTag::Return: {
        mut value: Option!<Rc!<Value>>;

        if node.return_node.expression.is_some() {
          value = Some(self.visit_expression(self.get_node(node.return_node.expression.unwrap())));
        }

        return .{
          control_flow: ControlFlow::Return,
          value: value,
        };
      }
      NodeTag::Variable: {
        return self.visit_variable(node);
      }
    }
    return .{};
  }

  run :: fn(*mut self) -> Value {
    mut visited_indices: NodeID[];
    for i in 0..self.nodes.length {
      node := &mut self.nodes[i];
      if node.tag == NodeTag::Function {
        visited_indices.push(i);
        self.visit_function_header(node);
      }
    }

    for i in 0..self.nodes.length {
      // already visited.
      // we could probably just remove these nodes, but we need them to stay alive.
      if visited_indices.contains(i, fn(a: u32, b: u32) -> bool {
        return a == b;
      }) then continue;

      node := self.get_node(i);
      // println(node.tag);
      self.visit_statement(node);
    }

    return .{};
  }
}