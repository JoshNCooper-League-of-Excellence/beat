import fmt::*;
import lexer::*;
import rc::*;
import map::Map;

alias NodeID :: u32;

ValueTag :: enum {
  None,
  Number,
  String,
  Boolean,
  Object,
  Array,
  Function,
  NativeFunction,
}

Value :: struct;
alias NativeFunction :: fn *(List!<Rc!<Value>>) -> Rc!<Value>;

Value :: struct {
  tag: ValueTag,
  #anon :: union {
    number: f64,
    string: String,
    boolean: bool,
    object: Map!<String, Rc!<Value>>,
    array:  List!<Rc!<Value>>,
    function: *mut Function,
    native_function: NativeFunction,
  }
}

impl Value {
  None :: fn() -> Rc!<#self> {
    #static mut none: Rc!<#self>;
    if none.ptr == null {
      none = Rc!<Value>::new(Value.{});
    }
    return none;
  }

  True :: fn() -> Rc!<#self> {
    return Rc!<Value>::new(Value.{
      tag: ValueTag::Boolean,
      boolean: true,
    });
  }

  False :: fn() -> Rc!<#self> {
    return Rc!<Value>::new(Value.{
      tag: ValueTag::Boolean,
      boolean: false,
    });
  }

  Bool :: fn(value: bool) -> Rc!<#self> {
    return Rc!<Value>::new(Value.{
      tag: ValueTag::Boolean,
      boolean: value,
    });
  }

  is_truthy :: fn(self) -> bool {
    return switch self.tag {
      ValueTag::None => false,
      ValueTag::Number => self.number != 0.0,
      ValueTag::String => self.string.length != 0,
      ValueTag::Boolean => self.boolean,
      ValueTag::Object => self.object.length != 0,
      ValueTag::Array => self.array.length != 0,
      ValueTag::Function => true,
      ValueTag::NativeFunction => true,
    };
  }
}

Scope :: struct {
  parent: Option!<*mut Scope>,
  symbols: Map!<String, Rc!<Value>>,
}

impl Scope {
  insert :: fn(*mut self, key: String, value: Rc!<Value>) {
    mut node := self;
    while {
      option := node.symbols.get_mut(key);
      if option.is_some() {
        *option.unwrap() = value.clone();
        return;
      }
      if node.parent.is_none() {
        break;
      }
      node = node.parent.unwrap();
    }
    self.symbols.insert(key, value.clone());
  }
  lookup :: fn(*const self, key: String) -> Option!<Rc!<Value>> {
    mut option := self.symbols.get(key);
    if option.is_none() && self.parent.is_some() {
      return self.parent.unwrap().lookup(key);
    }

    if option.is_some() {
      option = Some(option.unwrap().clone());
    }
    return option;
  }
  create_child :: fn(*mut self) -> *mut Scope {
    return new(Scope.{
      parent: Some(self),
    });
  }
}

Unary :: struct {
  operand: NodeID,
  operator: TType,
}

Binary :: struct {
  left: NodeID,
  right: NodeID,
  operator: TType,
}

MemberAccess :: struct {
  base: NodeID,
  member: String,
}

Subscript :: struct {
  base: NodeID,
  index: NodeID,
}

Call :: struct {
  callee: NodeID,
  arguments: NodeID[]
}

ObjectLiteral :: struct {
  key_values: Map!<String, NodeID>,
}

ArrayLiteral :: struct {
  values: NodeID[],
}

Block :: struct {
  scope: *mut Scope,
  statements: Node[],
}

Function :: struct {
  name: String,
  parameters: String[],
  block: Block,
}

TypeDeclaration :: struct {
  name: String,
  members: Map!<String, Option!<NodeID>>,
}

If :: struct {
  condition: NodeID,
  block: NodeID,
  else_node: Option!<NodeID>,
}

Else :: struct {
  if_node: Option!<NodeID>,
  block: Option!<NodeID>,
}

While :: struct {
  condition: Option!<NodeID>,
  block: NodeID,
}

For :: struct {
  target: NodeID,
  identifier: String,
  block: NodeID,
}

Return :: struct {
  expression: Option!<NodeID>
}

Variable :: struct {
  name: String,
  value: Option!<NodeID>,
}

NodeTag :: enum {
  None, // 'none' value, not an invalid ntag.
  Boolean,
  Number,
  String,
  Identifier,
  Binary,
  Unary,
  MemberAccess,
  Subscript,

  ObjectLiteral,
  ArrayLiteral,

  Block,
  Function,

  If,
  Else,
  While,
  For,

  Return,
  Continue,
  Break,

  Variable,
  Call,
}

Node :: struct {
  tag: NodeTag,
  id: NodeID,
  #anon :: union {
    boolean: bool,
    number: f64,
    string: String,
    identifier: String,
    binary: Binary,
    unary: Unary,

    object_literal: ObjectLiteral,
    array_literal: ArrayLiteral,

    function: Function,
    block: Block,

    if_node: If,
    else_node: Else,
    for_node: For,
    while_node: While,

    return_node: Return,

    call: Call,
    member_access: MemberAccess,
    variable: Variable,
    subscript: Subscript,
  },
}

impl Format for Value {
  format :: fn(*const self, builder: *mut StringBuilder, options: FormatOptions) {
    switch self.tag {
      ValueTag::None: {
        builder.append("none");
      }
      ValueTag::Number: {
        builder.appendf("%", (self.number,), options);
      }
      ValueTag::String: {
        builder.appendf("\"%\"", (self.string,), options);
      }
      ValueTag::Boolean: {
        builder.appendf("%", (self.boolean,), options);
      }
      ValueTag::Object: {
        builder.append("{ ");
        if options.indented {
          builder.append("\n  ");
        }
        mut index := 0;
        for key, value in self.object {
          builder.appendf("\"%\": ", (key,), options);
          (*value).format(builder, options);
          if options.indented && index != self.object.length - 1 {
            builder.append(",\n  ");
          } else if index != self.object.length - 1 {
            builder.append(", ");
          }
          index++;
        }
        if options.indented {
          builder.append("\n");
        }
        builder.append(" }");
      }
      ValueTag::Array: {
        builder.append("[");
        if options.indented then builder.append("\n  ");
        
        mut index := 0;
        for value in self.array {
          (*value).format(builder, options);;
          if options.indented && index != self.array.length - 1 {
            builder.append(",\n  ");
          } else if index != self.array.length - 1 {
            builder.append(", ");
          }
          index++;
        }
        if options.indented then builder.append("\n");
        builder.append("]");
      }
      ValueTag::Function: {
        builder.append("fn(");
        mut index := 0;
        for param in self.function.parameters {
          if index != self.function.parameters.length - 1 {
            builder.appendf("%, ", (param,), options);
          } else {
            builder.appendf("%", (param,), options);
          }
        }
        builder.append(")");
      }
      ValueTag::NativeFunction: {
        builder.append("@builtin::fn()");
      }
    }
  }
}

impl Rc!<Value> {
  eq :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag != other.ptr.tag {
      return Value::False();
    } 

    switch self.ptr.tag {
      ValueTag::None => Value::True(),
      ValueTag::Number => Value::Bool(self.ptr.number == other.ptr.number),
      ValueTag::String => Value::Bool(self.ptr.string == other.ptr.string),
      ValueTag::Boolean => Value::Bool(self.ptr.boolean == other.ptr.boolean),
      ValueTag::Object: {
        if self.ptr.object.length != other.ptr.object.length {
          return Value::False();
        } else {
          for key, value in self.ptr.object {
            if !other.ptr.object.contains(key) {
              return Value::False();
            }
            other_value := other.ptr.object.get(key).unwrap();
            if !value.eq(other_value).ptr.boolean {
              return Value::False();
            }
          }
          return Value::True();
        }
      }
      ValueTag::Array: {
        if self.ptr.array.length != other.ptr.array.length {
          return Value::False();
        } else {
          for i in 0..self.ptr.array.length {
            if !self.ptr.array[i].eq(other.ptr.array[i]).ptr.boolean {
              return Value::False();
            }
          }
          return Value::True();
        }
      }
      ValueTag::Function => Value::Bool(self.ptr.function == other.ptr.function),
      ValueTag::NativeFunction => Value::Bool(self.ptr.native_function == other.ptr.native_function),
    }
    return Value::False();
  }
  neq :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    return Value::Bool(!self.eq(other).ptr.boolean);
  }
}

impl Rc!<Value> {
  add :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag == ValueTag::Number && other.ptr.tag == ValueTag::Number {
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Number,
        number: self.ptr.number + other.ptr.number,
      });
    } else if self.ptr.tag == ValueTag::String {
      mut builder: StringBuilder;
      builder.append(self.ptr.string);
      other.ptr.format(&mut builder, FormatOptions::default());
      string := builder.get_string();
      builder.deinit();
      return Rc!<Value>::new(Value.{
        tag: ValueTag::String,
        string: string,
      });
    } else if self.ptr.tag == ValueTag::Array {
      self.ptr.array.push(other);
      return self;
    }

    return Value::None();
  }
  sub :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag == ValueTag::Number && other.ptr.tag == ValueTag::Number {
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Number,
        number: self.ptr.number - other.ptr.number,
      });
    } else {
      panic("subtraction is only supported for numbers");
      return Value::None();
    }
  }
  mul :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag == ValueTag::Number && other.ptr.tag == ValueTag::Number {
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Number,
        number: self.ptr.number * other.ptr.number,
      });
    } else {
      panic("multiplication is only supported for numbers");
      return Value::None();
    }
  }
  div :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag == ValueTag::Number && other.ptr.tag == ValueTag::Number {
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Number,
        number: self.ptr.number / other.ptr.number,
      });
    } else {
      panic("division is only supported for numbers");
      return Value::None();
    }
  }
  lt :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag == ValueTag::Number && other.ptr.tag == ValueTag::Number {
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Boolean,
        boolean: self.ptr.number < other.ptr.number,
      });
    } else {
      panic("less than comparison is only supported for numbers");
      return Value::None();
    }
  }
  lte :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag == ValueTag::Number && other.ptr.tag == ValueTag::Number {
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Boolean,
        boolean: self.ptr.number <= other.ptr.number,
      });
    } else {
      panic("less than or equal comparison is only supported for numbers");
      return Value::None();
    }
  }
  gt :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag == ValueTag::Number && other.ptr.tag == ValueTag::Number {
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Boolean,
        boolean: self.ptr.number > other.ptr.number,
      });
    } else {
      panic("greater than comparison is only supported for numbers");
      return Value::None();
    }
  }
  gte :: fn(self, other: Rc!<Value>) -> Rc!<Value> {
    if self.ptr.tag == ValueTag::Number && other.ptr.tag == ValueTag::Number {
      return Rc!<Value>::new(Value.{
        tag: ValueTag::Boolean,
        boolean: self.ptr.number >= other.ptr.number,
      });
    } else {
      panic("greater than or equal comparison is only supported for numbers");
      return Value::None();
    }
  }
}