import fmt::*;
import lexer::*;
import rc::*;
import map::Map;

alias NodeID :: u32;

ValueTag :: enum {
  None,
  Number,
  String,
  Boolean,
  Object,
  Array,
  Function,
  NativeFunction,
}

Value :: struct;
alias NativeFunction :: fn *(List!<Rc!<Value>>) -> Rc!<Value>;

Value :: struct {
  tag: ValueTag,
  #anon :: union {
    number: f64,
    string: String,
    boolean: bool,
    object: Map!<String, Rc!<Value>>,
    array:  List!<Rc!<Value>>,
    function: *mut Function,
    native_function: NativeFunction,
  }
}

impl Value {
  None :: fn() -> Rc!<#self> {
    #static mut none: Rc!<#self>;
    if none.ptr == null {
      none = Rc!<Value>::new(Value.{});
    }
    return none;
  }
}

Scope :: struct {
  parent: Option!<*mut Scope>,
  symbols: Map!<String, Rc!<Value>>,
}

impl Scope {
  insert :: fn(*mut self, key: String, value: Rc!<Value>) {
    mut node := self;
    while {
      option := node.symbols.get_mut(key);
      if option.is_some() {
        *option.unwrap() = value.clone();
        return;
      }
      if node.parent.is_none() {
        break;
      }
      node = node.parent.unwrap();
    }
    self.symbols.insert(key, value.clone());
  }
  lookup :: fn(*const self, key: String) -> Option!<Rc!<Value>> {
    mut option := self.symbols.get(key);
    if option.is_none() && self.parent.is_some() {
      return self.parent.unwrap().lookup(key);
    }

    if option.is_some() {
      option = Some(option.unwrap().clone());
    }
    return option;
  }
  create_child :: fn(*mut self) -> *mut Scope {
    return new(Scope.{
      parent: Some(self),
    });
  }
}

Unary :: struct {
  operand: NodeID,
  operator: TType,
}

Binary :: struct {
  left: NodeID,
  right: NodeID,
  operator: TType,
}

MemberAccess :: struct {
  base: NodeID,
  member: String,
}

Subscript :: struct {
  base: NodeID,
  index: NodeID,
}

Call :: struct {
  callee: NodeID,
  arguments: NodeID[]
}

ObjectLiteral :: struct {
  key_values: Map!<String, NodeID>,
}

ArrayLiteral :: struct {
  values: NodeID[],
}

Block :: struct {
  scope: *mut Scope,
  statements: Node[],
}

Function :: struct {
  name: String,
  parameters: String[],
  block: Block,
}

TypeDeclaration :: struct {
  name: String,
  members: Map!<String, Option!<NodeID>>,
}

If :: struct {
  condition: NodeID,
  block: NodeID,
  else_node: Option!<NodeID>,
}

Else :: struct {
  if_node: Option!<NodeID>,
  block: Option!<NodeID>,
}

While :: struct {
  condition: Option!<NodeID>,
  block: NodeID,
}

For :: struct {
  target: NodeID,
  identifier: String,
  block: NodeID,
}

Return :: struct {
  expression: Option!<NodeID>
}

Variable :: struct {
  name: String,
  value: Option!<NodeID>,
}

NodeTag :: enum {
  None, // 'none' value, not an invalid ntag.
  Boolean,
  Number,
  String,
  Identifier,
  Binary,
  Unary,
  MemberAccess,
  Subscript,

  ObjectLiteral,
  ArrayLiteral,

  Block,
  Function,

  If,
  Else,
  While,
  For,

  Return,
  Continue,
  Break,

  Variable,
  Call,
}

Node :: struct {
  tag: NodeTag,
  id: NodeID,
  #anon :: union {
    boolean: bool,
    number: f64,
    string: String,
    identifier: String,
    binary: Binary,
    unary: Unary,

    object_literal: ObjectLiteral,
    array_literal: ArrayLiteral,

    function: Function,
    block: Block,

    if_node: If,
    else_node: Else,
    for_node: For,
    while_node: While,

    return_node: Return,

    call: Call,
    member_access: MemberAccess,
    variable: Variable,
    subscript: Subscript,
  },
}

impl Format for Value {
  format :: fn(*const self, builder: *mut StringBuilder, options: FormatOptions) {
    switch self.tag {
      ValueTag::None: {
        builder.append("none");
      }
      ValueTag::Number: {
        builder.appendf("%", (self.number,), options);
      }
      ValueTag::String: {
        builder.appendf("\"%\"", (self.string,), options);
      }
      ValueTag::Boolean: {
        builder.appendf("%", (self.boolean,), options);
      }
      ValueTag::Object: {
        builder.append("{ ");
        if options.indented {
          builder.append("\n  ");
        }
        mut index := 0;
        for key, value in self.object {
          builder.appendf("\"%\": ", (key,), options);
          (*value).format(builder, options);
          if options.indented && index != self.object.length - 1 {
            builder.append(",\n  ");
          } else if index != self.object.length - 1 {
            builder.append(", ");
          }
          index++;
        }
        if options.indented {
          builder.append("\n");
        }
        builder.append(" }");
      }
      ValueTag::Array: {
        builder.append("[");
        if options.indented then builder.append("\n  ");
        
        mut index := 0;
        for value in self.array {
          (*value).format(builder, options);;
          if options.indented && index != self.array.length - 1 {
            builder.append(",\n  ");
          } else if index != self.array.length - 1 {
            builder.append(", ");
          }
          index++;
        }
        if options.indented then builder.append("\n");
        builder.append("]");
      }
      ValueTag::Function: {
        builder.append("fn(");
        mut index := 0;
        for param in self.function.parameters {
          if index != self.function.parameters.length - 1 {
            builder.appendf("%, ", (param,), options);
          } else {
            builder.appendf("%", (param,), options);
          }
        }
        builder.append(")");
      }
      ValueTag::NativeFunction: {
        builder.append("@builtin::fn()");
      }
    }
  }
}

