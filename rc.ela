Rc :: struct!<T> {
  ptr: *mut T,
  rc: *mut u64,
}

impl!<T> Rc!<T> {
  // this hack to aleviate annoyances.
  deinit :: fn(*const self) {
    mut_self := self as *mut #self;
    *mut_self.rc -= 1;
    if *mut_self.rc <= 0 {
      free(mut_self.ptr);
      free(mut_self.rc);
    }
  }
}

impl!<T> Rc!<T> {
  clone :: fn(*const self) -> #self {
    mut_self := self as *mut #self;
    *mut_self.rc += 1;
    return .{
      ptr: mut_self.ptr,
      rc: mut_self.rc,
    }
  }
}

impl!<T> Rc!<T> {
  new :: fn(value: T) -> #self {
    return .{
      ptr:  new(value),
      rc:   new(1 as u64),
    }
  }
  
  from :: fn(value: *mut T) -> #self {
    return .{
      ptr: value,
      rc: new(1 as u64),
    };
  }

  empty :: fn() -> #self {
    return .{
      ptr: null,
      rc:  new(1 as u64)
    }
  }

  /* 
    it seems weird, but we just pass the pointer out,
    the one we want dereference.
    this allows the compiler to dereference it, and this allows us
    to assign via this pointer, instead of always just getting a value.
  */
  deref :: fn(self) -> *mut T {
    return self.ptr;
  }
}
